package edu.gatech.mbsec.adapter.magicdraw.editor;

import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;
import javassist.bytecode.ConstPool;
import javassist.bytecode.annotation.MemberValue;
import javassist.bytecode.annotation.StringMemberValue;

/**
 * A {@code String} {@link MemberEditor member editor}.
 * @author rherrera
 */
public class StringMemberEditor implements MemberEditor<StringMemberValue> {
    /**
     * Logger of this class.
     */
    private static final Logger LOG = Logger.getLogger(StringMemberEditor.class.getName());
    /**
     * If set, a new value for the member will be generated by replacing this
     * pattern on the old member's value with the {@code value} string.
     */
    private final String replacePattern;
    /**
     * If set, only those member's whose old value matches this regex will be
     * updated; if null all members will be updated, a.k.a: no filter.
     */
    private final String filter;
    /**
     * The new value to set.
     */
    private final String value;
    /**
     * Constructs an instance specifying all properties.
     * @param value the new member's value.
     * @param filter if set, only those member's whose old value matches this
     * regex will be updated; if null all members will be updated,
     * a.k.a: no filter.
     * @param replacePattern ff set, a new value for the member will be
     * generated by replacing this pattern on the old member's value with
     * the {@code value} string.
     */
    public StringMemberEditor(String value, String filter, String replacePattern) {
        this.value = Objects.requireNonNull(value);
        this.replacePattern = replacePattern;
        this.filter = filter;
    }
    /**
     * Convenient constructor to set {@code null} as default
     * {@code replacePattern}.
     * @param value the new member's value.
     * @param filter if set, only those member's whose old value matches this
     * regex will be updated; if null all members will be updated,
     * a.k.a: no filter.
     */
    public StringMemberEditor(String value, String filter) {
        this(value, filter, null);
    }
    /**
     * Convenient constructor to set {@code null} as default
     * {@code replacePattern} and default {@code filter}.
     * @param value the new member's value.
     */
    public StringMemberEditor(String value) {
        this(value, null);
    }
    /**
     * Gets the replace pattern of this editor. If set, a new value for the
     * member will be generated by replacing this pattern on the old member's
     * value with the {@code value} string.
     * @return the replace pattern of this editor.
     */
    public String getReplacePattern() {
        return replacePattern;
    }
    /**
     * Gets the filter of this editor. If set, only those member's whose old
     * value matches this regex will be updated; if null all members will be
     * updated, a.k.a: no filter.
     * @return the filter of this editor.
     */
    public String getFilter() {
        return filter;
    }
    /**
     * Gets the new value to set of this editor.
     * @return the new value to set of this editor.
     */
    public String getValue() {
        return value;
    }

    @Override
    public boolean canEdit(MemberValue member) {
        return member instanceof StringMemberValue;
    }

    @Override
    public StringMemberValue edit(StringMemberValue old, String name,
            ConstPool pool) {
        StringMemberValue edited = old;
        String oldValue = old.getValue();
        if (filter == null || oldValue.matches(filter)) {
            if (replacePattern == null) {
                edited = new StringMemberValue(value, pool);
                LOG.log(Level.FINER, "[1] {0}: {1} > {2}", new Object[]{name, oldValue, value});
            } else {
                oldValue = oldValue.replaceAll(replacePattern, value);
                edited = new StringMemberValue(oldValue, pool);
                LOG.log(Level.FINER, "[1] {0}: {1} ~ {2}", new Object[]{name, old.getValue(), oldValue});
            }
        } else {
            LOG.log(Level.FINER, "[0] {0}: {1} | {2}", new Object[]{name, oldValue, filter});
        }
        return edited;
    }

}